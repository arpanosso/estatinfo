<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Estatística &amp; Estatística e Informática</title>
    <meta charset="utf-8" />
    <meta name="author" content="Alan Rodrigo Panosso alan.panosso@unesp.br" />
    <script src="libs/header-attrs-2.29/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Estatística &amp; Estatística e Informática
]
.subtitle[
## Apresentação da disciplina
]
.author[
### Alan Rodrigo Panosso <a href="mailto:alan.panosso@unesp.br" class="email">alan.panosso@unesp.br</a>
]
.institute[
### Departamento Ciências Exatas
]
.date[
### <p>26 e 27 de fevereiro de 2026
CURSOS: Agronomia e Administração</p>
]

---


**ALAN RODRIGO PANOSSO**  

**Professor Associado ** 

Departamento de Ciências Exatas  

E-mail: &lt;alan.panosso@unesp.br&gt;   |  Tel: (16) 3209-7210  


**Formação e Atuação Profissional**

`\(^{[1]}\)` Engenheiro Agrônomo formado pela FCAV/Unesp Jaboticabal (2000-2004)

`\(^{[2]}\)` Mestre em Agronomia (Ciência do Solo) pelo programa de Pós-Graudação da FCAV/Unesp Jaboticabal (2005-2006). 

`\(^{[3]}\)` Doutor em Agronomia (Produção Vegetal) pelo programa de Pós-Graudação da FCAV/Unesp Jaboticabal (2007-2011).

`\(^{[4]}\)` Pós-Doutorado em Agronomia (Ciência do Solo) pela FCAV/Unesp Jaboticabal (2011 - 2013).

`\(^{[5]}\)` Livre Docente (Experimentação Agrícola) pelo Departamento de Engenharia e Ciências Exatas da FCAV/Unesp Jaboticabal (2023).

`\(^{[6]}\)` COordenador do Programa de Pós-graduação em Agronomia (Ciência do Solo) E Vice-Chefe do Departamento de Ciências Exatas da FCAV/Unesp Jaboticabal (Atual).

---

## Material Didático

#### 01 - Acesse: https://www.fcav.unesp.br/alan .

![](img/app01.png)
---

## Material Didático

##### 02 - Selecione **Estatística &amp; Estatística e Informática** no menu lateral.

![](img/app02.png)


---


#### Material Didático

Você terá acesso à página da disciplina com todo o material que será utilizado durante o curso, como apresentações, tabelas, listas, e calendário com as aulas programadas, inclusive os dias das avaliações.

![](img/app04.png)
---
## Ementa da disciplina

- Introdução

- Estatística Descritiva

- Ditribuições de Probabilidade

- Amostragem

- Estimação de Parâmetros

- Intervalos de confiança

- Testes de Hipótese

- Correlação e Regressão linear simples

---

## Objetivos

- Resumir  e  apresentar  dados  por meio de  tabelas,  gráficos  e  medidas.  

- Inferir  resultados  amostrais para as populações alvo por meio de  técnicas estatísticas apropriadas.


---

## Avaliações

Serão  realizados **02  Provas** ( `\(P1\)` e `\(P2\)` ). 

A  nota  de  aproveitamento da disciplina será  a  média  ponderada  das notas das provas, dada por:

$$
\text{Média Final} = \frac{2 \cdot P_1 + 3 \cdot P_2}{5}
$$

onde: 

`\(P_1\)` = Nota da 1ª prova; 

`\(P_2\)` = Nota do 2ª Prova

**Observação:** Será aplicada prova substitutiva aos alunos que perderem uma das avaliações ou que desejarem refazê-la para melhoria da média final.

---

| Dia	| Semana	| Conteúdo |  
|:--- | :---: | :---:|
| 26 e 27 de fevereiro de 2026	| 1 | Apresentação da Disciplina 
| 05 e 06 de março de 2026	| 2 | Introdução à Estatística	
| 12 e 13 de março de 2026	| 3 | Medidas Estatísticas	
| 19 e 20 de março de 2026	| 4 | Probabilidade	 Parte I
| 26 e 27 de março de 2026	| 5 | Probabilidade	 Parte II 	
| 09 e 10 de abril de 2026	| 6 | Variáveis Aleatórias Discretas	
| 16 e 17 de abril de 2026	| 7 | Variáveis Aleatórias Contínuas	
|**23 e 24 de abril de 2026**	| **8** | **Prova 01**
| 07 e 08 de maio de 2026	| 9 | Estatística e Distribuição Amostral	
| 14 e 15 de maio de 2026	| 10 | Estimação	
| 21 e 22 de maio de 2026	| 11 | SECITAP	
| 28 e 29 de maio de 2026	| 12 | Testes de Hipóteses Parte I	
| 11 e 12 de junho de 2026 | 13 | Testes de Hipóteses Parte II
|**18 e 19 de junho de 2026**	| **14** | **Prova 02** 
|**25 e 26 de junho de 2026**	| **15** | **Prova Substitutiva**	
|**02 e 03 de julho de 2026**	| **16** | **Período de Recuperação**	

---

## Metodologia de Ensino

- Aulas teóricas expositivas.

- Resolução de listas de exercícios.  

- Apostila didática [Baixar Apostila](https://www.fcav.unesp.br/Home/departamentos/cienciasexatas/alanrodrigopanosso/apostila_bioestatistica_2019.pdf)

- Material Didático: [Link](https://www.fcav.unesp.br/#!/departamentos/ciencias-exatas/docentes/alan-rodrigo-panosso/material-didatico/estatistica-e-informatica/)

- Consulta a livros.

---

## Bibliografia básica

BUSSAB, W. O.; MORETTIN, P. A. **Estatística Básica**. 5 ed.  São Paulo: Saraiva, 2002.  p. [LINK](https://www.amazon.com.br/Estat%C3%ADstica-B%C3%A1sica-Wilton-Bussab/dp/8547220224/ref=asc_df_8547220224/?tag=googleshopp00-20&amp;linkCode=df0&amp;hvadid=379748610448&amp;hvpos=&amp;hvnetw=g&amp;hvrand=13078554075477532168&amp;hvpone=&amp;hvptwo=&amp;hvqmt=&amp;hvdev=c&amp;hvdvcmdl=&amp;hvlocint=&amp;hvlocphy=1031739&amp;hvtargid=pla-811770768458&amp;psc=1)

FORBELLONE A. L.; EBERSPACHER, H. **Lógica de Programação: A Construção de Algoritmos e Estruturas de Dados**. São Paulo: Editora Pearson Universidades, 2005. 218 p. [LINK](https://www.amazon.com.br/L%C3%B3gica-programa%C3%A7%C3%A3o-constru%C3%A7%C3%A3o-algoritmos-estruturas/dp/8576050242/ref=sr_1_2?__mk_pt_BR=%C3%85M%C3%85%C5%BD%C3%95%C3%91&amp;crid=10ANF2PLKU3KG&amp;keywords=l%C3%B3gica+de+programa%C3%A7%C3%A3o+a+constru%C3%A7%C3%A3o+de+algoritmos&amp;qid=1678318256&amp;sprefix=l%C3%B3gica+de+programa%C3%A7%C3%A3o+a+constru%C3%A7%C3%A3o+de+algoritmo%2Caps%2C241&amp;sr=8-2&amp;ufe=app_do%3Aamzn1.fos.6121c6c4-c969-43ae-92f7-cc248fc6181d)

MAGALHÃES, M. N.; LIMA, A. C. P. **Noções de Probabilidade e Estatística**.  São Paulo: Editora da Universidade de São Paulo, 2005. 392 p. [LINK](https://www.amazon.com.br/No%C3%A7%C3%B5es-Probabilidade-Estat%C3%ADstica-Nascimento-Magalh%C3%A3es/dp/8531406773/ref=asc_df_8531406773/?tag=googleshopp00-20&amp;linkCode=df0&amp;hvadid=379712528301&amp;hvpos=&amp;hvnetw=g&amp;hvrand=3043005081199790255&amp;hvpone=&amp;hvptwo=&amp;hvqmt=&amp;hvdev=c&amp;hvdvcmdl=&amp;hvlocint=&amp;hvlocphy=1031739&amp;hvtargid=pla-422923055890&amp;psc=1)

BLAIR, R. C.; TAYLOR, R. A. **Bioestatística para ciências da saúde**.  São Paulo: Pearson Education do Brasil, 2013. 469 p. [LINK](https://www.submarino.com.br/produto/1368960931/livro-bioestatistica-para-ciencias-da-saude?WT.srch=1&amp;acc=d47a04c6f99456bc289220d5d0ff208d&amp;epar=bp_pl_00_go_g35177&amp;gclid=Cj0KCQjw1PSDBhDbARIsAPeTqretIWgohh4CuyLOwGdNd-W56zb9kfuDNz9YaVg3KmFtZXGWyZuk1REaAhW-EALw_wcB&amp;i=561e53416ed24cafb5322074&amp;o=5ec29a42f8e95eac3dc7d8f4&amp;opn=XMLGOOGLE&amp;sellerid=03)

BATSCHELET, E. **Introdução à matemática para biocientistas**.  São Paulo: Ed. Da Universidade de São Paulo., 1978. 596 p. [LINK](https://www.amazon.com.br/Introdu%C3%A7%C3%A3o-%C3%A0-Matem%C3%A1tica-Para-Biocientistas/dp/8571930295/ref=asc_df_8571930295/?tag=googleshopp00-20&amp;linkCode=df0&amp;hvadid=379751745514&amp;hvpos=&amp;hvnetw=g&amp;hvrand=15178690494420387835&amp;hvpone=&amp;hvptwo=&amp;hvqmt=&amp;hvdev=c&amp;hvdvcmdl=&amp;hvlocint=&amp;hvlocphy=1031739&amp;hvtargid=pla-836184941200&amp;psc=1)


---
class: middle, center

## Ferramentas de trabalho
### Calculadora Científica Cassio  *fs-82MS*

![](img/calculadora.png)

---

# A importância do Banco de Dados

## Por que o banco de dados é central na Estatística?

- O banco de dados é o insumo fundamental de qualquer análise estatística.
- A qualidade das conclusões depende diretamente da qualidade dos dados.
- Erros na coleta e organização comprometem toda a inferência.
- Dados bem estruturados permitem análises mais robustas e reprodutíveis.

![](img/exemplo_dados.png)

---

## Atividade inicial da disciplina

Nesta primeira etapa do curso, realizaremos um levantamento de dados a partir de informações fornecidas pelos próprios alunos.

Objetivos:

- Compreender o processo de coleta de dados.
- Discutir tipos de variáveis.
- Identificar possíveis vieses.
- Construir um banco de dados real para análise ao longo da disciplina.

&lt;img src="img/QRCode_form.png" height="255"&gt;

[LINK FORMULÁRIO](https://forms.gle/g8sPFWeN9DnaiGRN6)

---
&lt;img src="img/QRCode_form.png" height="650"&gt;
---
&lt;!-- --- --&gt;
&lt;!-- class: middle, center --&gt;

&lt;!-- # Linguagem Computacional --&gt;

&lt;!-- ![](img/R_logo.png) --&gt;

&lt;!-- --- --&gt;

&lt;!-- ##  Instalação do R e do RStudio --&gt;

&lt;!-- ![](img/video01.png) --&gt;
&lt;!-- Acesse o vídeo: [LINK](https://drive.google.com/file/d/1jE2sHYyr_SLYTU1QapHFZmqR0z3hgCAB/view?usp=sharing) --&gt;

&lt;!-- --- --&gt;

&lt;!-- ## Configurando o RStudio --&gt;

&lt;!-- ![](img/video02.png) --&gt;


&lt;!-- Acesse o vídeo: [LINK](https://drive.google.com/file/d/1Ycf3_iaaIH54DSf6-cxbqBfIyAtQqWrc/view?usp=sharing) --&gt;

&lt;!-- --- --&gt;
&lt;!-- ## Algumas Funções no RStudio --&gt;

&lt;!-- ![](img/video03.png) --&gt;


&lt;!-- Acesse o vídeo: [LINK](https://drive.google.com/file/d/1kAoKIladRS7Z-KB6_nA5fTRkBkVoTQeW/view?usp=sharing) --&gt;

&lt;!-- --- --&gt;

&lt;!-- class: center, middle, inverse --&gt;

&lt;!-- # Linguagem de Programação, Algoritmos --&gt;
&lt;!-- # &amp; --&gt;
&lt;!-- # Lógica de Programação --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Computador --&gt;

&lt;!-- &gt;“Computador é aquele que faz cômputos ou que calcula; máquina à base de circuitos eletrônicos que efetua grandes operações e cálculos gerais, de maneira ultra rápida."  --&gt;

&lt;!-- &gt;"Computador é a entidade mais veloz do mundo, pois fará qualquer coisa que nós lhe ordenarmos a uma velocidade extremamente alta."  --&gt;

&lt;!-- &gt;"Computador é um equipamento capaz de aceitar elementos relativos a um problema, submetê-lo a operações predeterminadas e chegar a um resultado." --&gt;

&lt;!-- ```{r, echo=FALSE, out.width="100%", fig.align='center'} --&gt;
&lt;!-- knitr::include_graphics("img/laptop.png") --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- #### Componentes básicos de um computador --&gt;

&lt;!-- ![](img/computador-basico.png) --&gt;

&lt;!-- O **processador** (ou microprocessador) é responsável pelo tratamento de informações armazenadas em memória (programas em código de máquina e dos dados). --&gt;

&lt;!-- A **memória** é responsável pela armazenagem dos programas e dos dados.  --&gt;

&lt;!-- **Periféricos**, que são os dispositivos responsáveis pelas entradas e saídas de dados do computador, ou seja, pelas interações entre o computador e o mundo externo. Exemplos de periféricos são o monitor, teclados, mouses, impressoras, etc. --&gt;

&lt;!-- **Barramento**, que liga todos estes componentes e é uma via de comunicação de alto desempenho por onde circulam os dados tratados pelo computador. --&gt;

&lt;!-- --- --&gt;

&lt;!-- ![](img/computador-basico-2.png) --&gt;
&lt;!-- --- --&gt;

&lt;!-- ![](img/processador.png) --&gt;

&lt;!-- --- --&gt;
&lt;!-- ### Exemplo de como funciona o computador: --&gt;

&lt;!-- Uso de um programa que faz cálculos matemáticos: --&gt;
&lt;!--   + Usuário digita: `\(10+20*2\)` --&gt;
&lt;!--   + **UC** recebe estes dados --&gt;
&lt;!--   + **UC** verifica que precisam ser calculados --&gt;
&lt;!--   + **UC** envia para a **ULA** --&gt;
&lt;!--   + **ULA** realiza o cálculo necessário --&gt;
&lt;!--   + **ULA** *retorna* o valor `\(50\)` para a **UC** --&gt;
&lt;!--   + **UC** armazena na memória --&gt;
&lt;!--   + **UC** mostra o resultado no dispositivo de saída --&gt;

&lt;!-- --- --&gt;
&lt;!-- class: middle, center, inverse --&gt;

&lt;!-- # Conceitos Básicos --&gt;


&lt;!-- --- --&gt;

&lt;!-- ## Linguagem de programação --&gt;

&lt;!-- É o conjunto de palavras e regras que permitem **comunicar** ao computador o que este deve **executar**. --&gt;

&lt;!-- Em computação, uma linguagem de programação é a ferramenta de **comunicação** entre o **programador** que visa resolver um problema e o **computador** que irá ajudá-lo a resolver. --&gt;


&lt;!-- ```{r, echo=FALSE, out.width="65%", fig.align='center'} --&gt;
&lt;!-- knitr::include_graphics("img/linguagens-programacao.png") --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- ## Algoritmo --&gt;

&lt;!-- Sequência lógica e não ambígua de **instruções** que levam à solução de um problema num tempo finito. --&gt;


&lt;!--   + As instruções devem ser definidas em uma ordem correta. --&gt;

&lt;!--   + A sequência lógica e as instruções não devem dar margem à dupla interpretação. --&gt;

&lt;!--   + A sequência lógica deve resolver exatamente (nem mais e nem menos) o problema identificado. --&gt;

&lt;!--   + A sequência lógica não deve possuir iterações infinitas. --&gt;


&lt;!-- -- --&gt;

&lt;!-- ### Atenção: --&gt;
&lt;!-- Um algoritmo é **“uma solução”** e não **“a solução”** de um problema. --&gt;
&lt;!-- Um problema pode ser resolvido por mais de um algoritmo! ** -- SEMPRE -- ** --&gt;

&lt;!-- Tarefas que possuem **“padrão de comportamento”** podem ser descritas por um algoritmo. --&gt;

&lt;!-- Ex: Qual será o próximo número da sequência `\(0,1,4,9,16,25\)`? --&gt;

&lt;!-- --- --&gt;
&lt;!-- **Exemplo 3** – Apresente os números de `\(1\)` a `\(10\)`, com os valores ímpares negativos e pares positivos. --&gt;

&lt;!-- Algoritmo - Pseudocódigo --&gt;

&lt;!-- ```{r, eval=FALSE} --&gt;
&lt;!-- início --&gt;
&lt;!--   inteiro: contador; --&gt;
&lt;!--   inteiro: resultado; --&gt;
&lt;!--   para contador &lt;- 1 até 10 faça  --&gt;
&lt;!--     resultado &lt;- contador * pot(-1, contador); --&gt;
&lt;!--     escreva(resultado); --&gt;
&lt;!--   fim para --&gt;
&lt;!-- fim. --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;
&lt;!-- **Exemplo 3** – Apresente os números de `\(1\)` a `\(10\)`, com os valores ímpares negativos e pares positivos. --&gt;

&lt;!-- Implementação em linguagem R --&gt;

&lt;!-- ```{r} --&gt;
&lt;!-- resultado &lt;- integer() --&gt;
&lt;!-- for(contador in 1:10){ --&gt;
&lt;!--   resultado &lt;- contador * (-1)^contador --&gt;
&lt;!--   print(resultado) --&gt;
&lt;!-- } --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;
&lt;!-- ## Lógica de Programação --&gt;

&lt;!-- É o encadeamento lógico de "*instruções*" para o desenvolvimento de "*programas*". --&gt;

&lt;!-- ### Instrução --&gt;
&lt;!-- + Informação que representa uma ação elementar que deve ser executada. --&gt;
&lt;!-- + O ";" (**ponto-e-vírgula**) indica o fim de uma instrução! --&gt;
&lt;!-- + Em **R** cada instrução deve ser digitada em uma linha, se mais de uma instrução for digitada na mesma linha, usa-se, então, o ponto-e-vírgula. --&gt;

&lt;!-- .pull-left[ --&gt;
&lt;!-- ```{r} --&gt;
&lt;!-- x &lt;- 2 --&gt;
&lt;!-- y &lt;- 3 --&gt;
&lt;!-- x*y --&gt;
&lt;!-- ``` --&gt;
&lt;!-- ] --&gt;

&lt;!-- .pull-right[ --&gt;
&lt;!-- ```{r} --&gt;
&lt;!-- x &lt;- 2; y &lt;- 3; x*y --&gt;
&lt;!-- ``` --&gt;
&lt;!-- ] --&gt;

&lt;!-- Ambas as instruções retornam o mesmo valor, `\(6\)`. --&gt;

&lt;!-- --- --&gt;

&lt;!-- ## Construindo algoritmos --&gt;

&lt;!-- Uma boa prática para construir algoritmos é dividir o problema em `\(3\)` fases (Entrada, Processamento e Saída). --&gt;

&lt;!-- ```{r, echo=FALSE, out.width="90%", fig.align='center'} --&gt;
&lt;!-- knitr::include_graphics("img/mantra.png") --&gt;
&lt;!-- ``` --&gt;

&lt;!-- **ENTRADA**: São os dados de entrada do algoritmo.   --&gt;

&lt;!-- **PROCESSAMENTO**: São os procedimentos utilizados para chegar ao resultado final.   --&gt;

&lt;!-- **SAÍDA**: São os dados já processados.   --&gt;


&lt;!-- --- --&gt;

&lt;!-- No algoritmo Fahrenheit-Celsius temos: --&gt;

&lt;!--   + **ENTRADA:** Temperatura em Fahrenheit   --&gt;

&lt;!--   + **PROCESSAMENTO:** Celsius = 5/9 *(Fahrenheit – 32)     --&gt;

&lt;!--   + **SAÍDA:** Temperatura em Celsius   --&gt;

&lt;!-- Num algoritmo para calcular a área de um triângulo temos: --&gt;

&lt;!-- -- --&gt;

&lt;!--   + **ENTRADA:** Base e Altura do triângulo   --&gt;

&lt;!--   + **PROCESSAMENTO:** Área = (Base * Altura)/2   --&gt;

&lt;!--   + **SAÍDA:** Área --&gt;

&lt;!-- -- --&gt;

&lt;!--   &gt; Dividir o problema em Entrada, Processamento e Saída irá ajudá-lo a ordenar corretamente as instruções do seus algoritmos. --&gt;

&lt;!-- Por isso, antes de construir um algoritmo, pare para pensar e identificar: --&gt;

&lt;!-- Que dados preciso para começar? – **Entrada**   --&gt;
&lt;!-- Quais são os cálculos e decisões? – **Processamento** --&gt;
&lt;!-- Que dados devem ser exibidos? – **Saída** --&gt;


&lt;!-- --- --&gt;

&lt;!-- ## Atividades --&gt;

&lt;!-- 1) Calcular e exibir a média ponderada de `\(2\)` notas dadas.    --&gt;
&lt;!-- (nota1 = peso `\(6\)` e nota2 = peso `\(4\)`). --&gt;

&lt;!-- -- --&gt;
&lt;!-- ```{r, eval=FALSE} --&gt;
&lt;!-- Algoritmo media-ponderada --&gt;
&lt;!-- Real: mediaP, nota1, nota2; --&gt;
&lt;!-- Início --&gt;
&lt;!--   Ler(nota1, nota2); --&gt;
&lt;!--   mediaP &lt;- (nota1*6 + nota2*4)/(6+4); --&gt;
&lt;!--   Escrever(mediaP); --&gt;
&lt;!-- Fim. --&gt;
&lt;!-- ``` --&gt;

&lt;!-- Implementação em R --&gt;

&lt;!-- ```{r} --&gt;

&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- 2) Reajustar um salário em `\(7,75%\)`. --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{r, eval=FALSE} --&gt;
&lt;!-- Algoritmo reajuste-salarial --&gt;
&lt;!-- Real: porcentagem, salario, novo_salario --&gt;
&lt;!-- Início --&gt;
&lt;!--   Ler(salario, porcentagem); --&gt;
&lt;!--   novo_salario = salario + salario*porcentagem; --&gt;
&lt;!--   Escrever(novo_salario); --&gt;
&lt;!-- Fim. --&gt;
&lt;!-- ``` --&gt;

&lt;!-- Implementação em R --&gt;

&lt;!-- ```{r} --&gt;
&lt;!-- porcentagem &lt;- 0.075 # real --&gt;
&lt;!-- salario &lt;- 1212.00 # real  --&gt;
&lt;!-- novo_salario &lt;- 0.00 # real --&gt;
&lt;!-- novo_salario = salario + salario*porcentagem # processamento --&gt;
&lt;!-- cat("Novo Salário: R$", round(novo_salario,2)) # saída --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- 3) Calcular o desconto de `\(23\%\)` sobre o preço de um produto. --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{r, eval=FALSE} --&gt;
&lt;!-- Algoritmo desconto --&gt;
&lt;!-- Real: preço, desconto; --&gt;
&lt;!-- Início --&gt;
&lt;!--   Ler(preço); --&gt;
&lt;!--   desconto &lt;- preço*0.23; --&gt;
&lt;!--   Escrever(desconto); --&gt;
&lt;!-- Fim. --&gt;
&lt;!-- ``` --&gt;

&lt;!-- Implementação em R --&gt;

&lt;!-- ```{r} --&gt;
&lt;!-- preco &lt;- 4274.90 #real --&gt;
&lt;!-- desconto &lt;- preco *23/100 --&gt;
&lt;!-- cat("desconto: R$ ", desconto) --&gt;
&lt;!-- cat("Preço com desconto: R$", preco-desconto) --&gt;
&lt;!-- ``` --&gt;


&lt;!-- --- --&gt;

&lt;!-- 4) Dada uma taxa de câmbio, transformar um valor em Dólar para Reais. --&gt;

&lt;!-- -- --&gt;

&lt;!-- ```{r, eval=FALSE} --&gt;
&lt;!-- Algoritmo dolar-real --&gt;
&lt;!-- Real: valor_dolar, taxa_cambio, valor_real; --&gt;
&lt;!-- Início --&gt;
&lt;!--   Ler(valor_dolar, taxa_cambio); --&gt;
&lt;!--   valor_real &lt;- valor_dolar * taxa_cambio; --&gt;
&lt;!--   Escrever(valor_real); --&gt;
&lt;!-- Fim. --&gt;
&lt;!-- ``` --&gt;

&lt;!-- Implementação em R --&gt;

&lt;!-- ```{r} --&gt;
&lt;!-- taxa_cambio &lt;- 5.24 --&gt;
&lt;!-- valor_dolar &lt;- 405.78 --&gt;
&lt;!-- valor_real &lt;- valor_dolar * taxa_cambio --&gt;
&lt;!-- cat("valor em R$", round(valor_real,2)) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- 5) Dada uma taxa de câmbio, transformar um valor em Reais para Dólar. --&gt;

&lt;!-- ```{r, eval=FALSE} --&gt;
&lt;!-- Algoritmo real-dolar --&gt;
&lt;!-- Real: valor_dolar, taxa_cambio, valor_real; --&gt;
&lt;!-- Início --&gt;
&lt;!--   Ler(valor_real, taxa_cambio); --&gt;
&lt;!--   valor_dolar &lt;- valor_real * taxa_cambio; --&gt;
&lt;!--   Escrever(valor_dolar); --&gt;
&lt;!-- Fim. --&gt;
&lt;!-- ``` --&gt;

&lt;!-- Implementação em R --&gt;

&lt;!-- ```{r} --&gt;
&lt;!-- taxa_cambio &lt;- 5.24 --&gt;
&lt;!-- valor_real &lt;- 4274.90 --&gt;
&lt;!-- valor_dolar &lt;- valor_real / taxa_cambio --&gt;
&lt;!-- cat("valor em USD", round(valor_dolar,2)) --&gt;
&lt;!-- ``` --&gt;


&lt;!-- --- --&gt;

&lt;!-- class: middle, center, inverse --&gt;

&lt;!-- # Conceitos Básicos --&gt;

&lt;!-- ## Identificadores e Palavras Reservadas --&gt;


&lt;!-- --- --&gt;

&lt;!-- ## Identificadores --&gt;

&lt;!-- São nomes únicos definidos pelos programadores para identificar/distinguir os elementos de um algoritmo. --&gt;


&lt;!-- -- --&gt;
&lt;!-- ## Palavras Reservadas --&gt;

&lt;!-- São instruções primitivas que têm significados pré-determinados e fazem parte da estrutura de qualquer linguagem de programação. --&gt;


&lt;!-- ```{r, eval=FALSE} --&gt;
&lt;!-- if; else; in; for; while; repeat; break; function --&gt;
&lt;!-- next; NULL; Inf; NA; NaN; TRUE; FALSE; T; F --&gt;
&lt;!-- ``` --&gt;


&lt;!-- --- --&gt;

&lt;!-- ### Algumas regras para os nomes de Identificadores: --&gt;

&lt;!-- 1) Devem começar por um caractere alfabético, nunca por um caractere numérico. --&gt;

&lt;!-- 2) Podem ser seguidos por mais caracteres alfabéticos e/ou numéricos. --&gt;

&lt;!-- 3) Não é permitido o uso de espaço em branco ou de caracteres especiais, como: @, #, &amp;, *, +, ?, $ (exceto o _ e o . ). --&gt;

&lt;!-- 4) Não poderá ser uma palavra reservada a uma instrução do algoritmo. --&gt;

&lt;!-- 5) Devem ser significativos. --&gt;

&lt;!-- 6) Não podem ser repetidos dentro de um mesmo algoritmo/sub-algoritmo. --&gt;

&lt;!-- --- --&gt;

&lt;!-- ## Recomendação --&gt;

&lt;!-- &gt; Você deseja que os nomes de seus objetos sejam descritivos, portanto, precisará adotar uma convenção para várias palavras. Recomendamos snake_case, onde você separa palavras minúsculas com underline. --&gt;

&lt;!-- ```{r, eval = FALSE} --&gt;
&lt;!-- i_use_snake_case # chatGPT_to #&lt;&lt; --&gt;
&lt;!-- otherPeopleUseCamelCase --&gt;
&lt;!-- some.people.use.periods --&gt;
&lt;!-- And_aFew.People_RENOUNCEconvention --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- ## Exercício --&gt;

&lt;!-- Identifique os erros e reescreva os identificadores abaixo: --&gt;

&lt;!-- vm --&gt;

&lt;!-- 13salário --&gt;

&lt;!-- salário$ --&gt;

&lt;!-- salário_mínimo  --&gt;

&lt;!-- salário+reajuste --&gt;

&lt;!-- novoSalário --&gt;

&lt;!-- fumante?  --&gt;

&lt;!-- preço médio --&gt;

&lt;!-- %desconto --&gt;

&lt;!-- km/h --&gt;

&lt;!-- --- --&gt;

&lt;!-- ## Exercício - Resposta --&gt;

&lt;!-- Identifique os erros, se houver, e reescreva os identificadores abaixo, se necessário: --&gt;

&lt;!-- vm: não tem significado, ideal `valor_médio`, por exemplo; --&gt;

&lt;!-- 13salário: não se inicial com número, ideal `salario_13`; --&gt;

&lt;!-- salário$: não utilizar caractere especial, ideal `salario`; --&gt;

&lt;!-- salário_mínimo: correto, outra opção seria `salario_minimo`; --&gt;

&lt;!-- salário+reajuste: não utilizar caractere especial, ideal `salario_reajuste`; --&gt;

&lt;!-- novoSalário: correto, outra opção `novoSalario`; --&gt;

&lt;!-- fumante? :não utilizar caractere especial, ideal `fumante`; --&gt;

&lt;!-- preço médio: não utilizar caractere especial, espaço, ideal `preco_medio`; --&gt;

&lt;!-- %desconto: não utilizar caractere especial, ideal `desconto`:  --&gt;

&lt;!-- km/h: não utilizar caractere especial, ideal `km_h`.  --&gt;

&lt;!-- --- --&gt;

&lt;!-- class: middle, center, inverse --&gt;

&lt;!-- # Tipos de Dados --&gt;

&lt;!-- --- --&gt;

&lt;!-- ### Tipos de Dados --&gt;

&lt;!-- As fases de **Entrada**, **Processamento** e **Saída** podem manipular vários tipos primitivos de dados, a saber:  --&gt;


&lt;!-- Tipo Primitivo | Descrição | Exemplo --&gt;
&lt;!-- :--- | :---: | :---: --&gt;
&lt;!-- Inteiro | Representa o conjunto de números inteiros | 1, 40, -8, 1024 --&gt;
&lt;!-- Real | Representa o conjunto de números reais | 3.14, 2.455, -9.88 --&gt;
&lt;!-- Caracter | Representa um ou mais caracteres do teclado | "Oi Mundo" --&gt;
&lt;!-- Lógico | Representa valor lógico (Verdadeiro ou Falso) | TRUE, FALSE --&gt;

&lt;!-- **OBS**: Um Caractere **SEMPRE** deve estar entre aspas "   " --&gt;

&lt;!-- Todos os exemplos abaixo serão considerados do tipo caractere:  --&gt;

&lt;!-- "A"    --&gt;
&lt;!-- "Discente",   --&gt;
&lt;!-- "Fone 3333-33333",    --&gt;
&lt;!-- "1"   --&gt;

&lt;!-- --- --&gt;

&lt;!-- **Exercício:** Classifique os dados de acordo com o seu tipo, sendo (I = Inteiro, R = Real, C = Caractere e L = Lógico):   --&gt;

&lt;!-- .pull-left[ --&gt;

&lt;!-- a(__)  0	    --&gt;

&lt;!-- b(__) + 36   --&gt;

&lt;!-- c(__) 0,3257   --&gt;

&lt;!-- d(__) F   --&gt;

&lt;!-- e(__)  1   --&gt;

&lt;!-- f(__) "F"   --&gt;

&lt;!-- g(__) "+3257"	   --&gt;

&lt;!-- h(__) -1   --&gt;

&lt;!-- i(__) 0,0       --&gt;

&lt;!-- j(__) - 0,001	      --&gt;

&lt;!-- k(__) "-0,0"	   --&gt;

&lt;!-- l(__) ".F."   --&gt;

&lt;!-- ] --&gt;

&lt;!--  .pull-right[ --&gt;
&lt;!--  m(__) "o" --&gt;

&lt;!--  n(__) +0,05	      --&gt;

&lt;!--  o(__) ".V."		   --&gt;

&lt;!--  p(__) 7/2 --&gt;

&lt;!--  q(__) 32      --&gt;

&lt;!--  r(__) +3257	      --&gt;

&lt;!--  s(__) V		   --&gt;

&lt;!--  t(__) -32    --&gt;

&lt;!--  u(__) "A"	   --&gt;

&lt;!--  v(__) "abc"	      --&gt;

&lt;!--  x(__) -1,9E123	   --&gt;

&lt;!--  z(__) "0"   --&gt;
&lt;!-- ] --&gt;

&lt;!-- --- --&gt;

&lt;!-- **Exercício: Respostas** Classifique os dados de acordo com o seu tipo, sendo (I = Inteiro, R = Real, C = Caractere e L = Lógico):   --&gt;

&lt;!-- .pull-left[ --&gt;

&lt;!-- a(I)  0	    --&gt;

&lt;!-- b(I) + 36   --&gt;

&lt;!-- c(R) 0,3257   --&gt;

&lt;!-- d(L) F   --&gt;

&lt;!-- e(I)  1   --&gt;

&lt;!-- f(C) "F"   --&gt;

&lt;!-- g(C) "+3257"	   --&gt;

&lt;!-- h(I) -1   --&gt;

&lt;!-- i(R) 0,0       --&gt;

&lt;!-- j(R) - 0,001	      --&gt;

&lt;!-- k(C) "-0,0"	   --&gt;

&lt;!-- l(C) ".F."   --&gt;

&lt;!-- ] --&gt;

&lt;!--  .pull-right[ --&gt;
&lt;!--  m(C) "o" --&gt;

&lt;!--  n(R) +0,05	      --&gt;

&lt;!--  o(C) ".V."		   --&gt;

&lt;!--  p(R) 7/2 --&gt;

&lt;!--  q(I) 32      --&gt;

&lt;!--  r(I) +3257	      --&gt;

&lt;!--  s(L) V		   --&gt;

&lt;!--  t(I) -32    --&gt;

&lt;!--  u(C) "A"	   --&gt;

&lt;!--  v(C) "abc"	      --&gt;

&lt;!--  x(R) -1,9E123	   --&gt;

&lt;!--  z(C) "0"   --&gt;
&lt;!-- ] --&gt;


&lt;!-- --- --&gt;
&lt;!-- class: middle, center, inverse --&gt;

&lt;!-- # Variável e Constante --&gt;

&lt;!-- --- --&gt;


&lt;!-- Exemplo de constantes no R: --&gt;

&lt;!-- ```{r} --&gt;
&lt;!-- pi # valor de Pi --&gt;
&lt;!-- exp(1) # constante de Euler --&gt;
&lt;!-- letters # letras minúsculas --&gt;
&lt;!-- LETTERS # letras maiúsculas --&gt;
&lt;!-- ``` --&gt;
&lt;!-- --- --&gt;

&lt;!-- Exemplo de constantes no R: --&gt;

&lt;!-- ```{r} --&gt;
&lt;!-- month.name # meses --&gt;
&lt;!-- month.abb # meses abreviados --&gt;
&lt;!-- ``` --&gt;


&lt;!-- --- --&gt;

&lt;!-- **Variável** é um **endereço físico** da memória principal, que é representado por um **identificador** que, ao longo do seu tempo de existência, pode armazenar vários conteúdos de um único tipo pré-determinado. --&gt;

&lt;!-- Endereço físico | Identificador	| Conteúdo	| Tipo --&gt;
&lt;!-- :--- | :---: | :---: | :---: | :---: --&gt;
&lt;!-- 1000:2000|	Nome|	"João" | Caracter --&gt;
&lt;!-- 2001:3000|	RG|	12345|	Inteiro --&gt;
&lt;!-- 3001:4000|	Salário|	999,99|	Real --&gt;
&lt;!-- 4001:5000|	Fumante|	F	|Lógico --&gt;

&lt;!-- ```{r} --&gt;
&lt;!-- x &lt;- 1:4 # x é um conunto de números que vão de 1 a 4 --&gt;
&lt;!-- print(x) --&gt;

&lt;!-- x[5] &lt;- "A" # x foi coagido a um conjunto de caracteres --&gt;
&lt;!-- print(x) --&gt;
&lt;!-- ``` --&gt;


&lt;!-- **OBS**: Conversão de tipos ou **COERÇÃO** são as diferentes formas de, implícita ou explicitamente, alterar uma entidade de um tipo de dados em outro. --&gt;


&lt;!-- --- --&gt;

&lt;!-- class: middle, center, inverse --&gt;

&lt;!-- # Expressões --&gt;

&lt;!-- --- --&gt;

&lt;!-- Uma **expressão** é uma fórmula para processamento de um valor. --&gt;

&lt;!-- As principais expressões são as seguintes: --&gt;

&lt;!-- **Aritméticas**: Retornam um valor numérico (inteiro ou real).    --&gt;
&lt;!-- EX: `\(10+(3+1)/2\)`  --&gt;
&lt;!-- RETORNO: `\(12\)` --&gt;

&lt;!-- ```{r} --&gt;
&lt;!-- 10+(3+1)/2 --&gt;
&lt;!-- ``` --&gt;

&lt;!-- **Relacionais**: Retornam um valor lógico `\(V\)` ou `\(F\)`.   --&gt;
&lt;!-- EX: `\(7 = 14/2\)`   --&gt;
&lt;!-- RETORNO: `\(VERDADEIRO\)` --&gt;

&lt;!-- No R o operador relacional de igualdade são dois sinais de igual (`==`). --&gt;
&lt;!-- ```{r} --&gt;
&lt;!-- (7 == 14/2)  --&gt;
&lt;!-- ``` --&gt;


&lt;!-- **Lógicas**: Retornam um valor lógico `\(V\)` ou `\(F\)`.   --&gt;
&lt;!-- EX: `\((3=2+1) E (3&gt;2)\)`   --&gt;
&lt;!-- RETORNO: `\(VERDADEIRO\)` --&gt;

&lt;!-- ```{r} --&gt;
&lt;!-- (3 == 2+1) &amp; (3&gt;2) --&gt;
&lt;!-- ``` --&gt;


&lt;!-- --- --&gt;


&lt;!-- --- --&gt;
&lt;!-- class: middle, center, inverse --&gt;

&lt;!-- # Operadores --&gt;


&lt;!-- --- --&gt;

&lt;!-- **Operadores Aritméticos**: são as operações aritméticas básicas. --&gt;

&lt;!-- ```{r, echo=FALSE, out.width="100%", fig.align='center'} --&gt;
&lt;!-- knitr::include_graphics("img/operadores-aritmeticos.png") --&gt;
&lt;!-- ``` --&gt;


&lt;!-- --- --&gt;

&lt;!-- ### Exemplos --&gt;

&lt;!-- Operador	| Operação	| Exemplo	| Resultado | No R --&gt;
&lt;!-- :--- | :--: | :---: | :---: | :---:  --&gt;
&lt;!-- +	| Adição| 	4+3	|7 | `4+3` --&gt;
&lt;!-- -	| Subtração| 	4-3 |	1 | `4 - 1` --&gt;
&lt;!-- *	| Multiplicação| 	4*3|	12 | `4 * 3`  --&gt;
&lt;!-- /	| Divisão| 	4/3	| 1,33 | `4 / 3` --&gt;
&lt;!-- MOD	| Resto da Divisão Inteira| 	5 MOD 3|	2 | `5 %% 3` --&gt;
&lt;!-- DIV	| Quociente da Divisão Inteira|	5 DIV 3|	1 | `5 %/% 3` --&gt;
&lt;!-- POT(x,y)	| Potenciação| 	POT (4,3)|	64 | `4^3` ou `4**3` --&gt;
&lt;!-- RAD(x)	| Radiciação| 	RAD(4)|	2 | `sqrt(4)` --&gt;
&lt;!-- +	| Manutenção do Sinal|	+- 4|	- 4 | `+(-4)` --&gt;
&lt;!-- -	| Inversão do Sinal	| -- 4|	+4 | `-(-4)` --&gt;

&lt;!-- --- --&gt;

&lt;!-- ### Exemplos - Implementados no R --&gt;

&lt;!-- .pull-left[ --&gt;
&lt;!-- ```{r} --&gt;
&lt;!-- 4+3 --&gt;
&lt;!-- 4 - 1 --&gt;
&lt;!-- 4 * 3  --&gt;
&lt;!-- 4 / 3 --&gt;
&lt;!-- 5 %% 3 --&gt;
&lt;!-- 5 %/% 3 --&gt;
&lt;!-- ``` --&gt;
&lt;!-- ] --&gt;

&lt;!-- .pull-right[ --&gt;
&lt;!-- ```{r} --&gt;
&lt;!-- 4^3 --&gt;
&lt;!-- 4**3 --&gt;
&lt;!-- sqrt(4) --&gt;
&lt;!-- +-4 --&gt;
&lt;!-- --4 --&gt;
&lt;!-- ``` --&gt;
&lt;!-- ] --&gt;

&lt;!-- --- --&gt;
&lt;!-- **Operadores Relacionais**: são operadores binários (de mesma prioridade) que somente retornam os valores lógicos `\(V\)` ou `\(F\)`. --&gt;

&lt;!-- Operador| Símbolo	| Comparação | Exemplo no R | Retorno --&gt;
&lt;!-- :--- | :---: |:---: | :---: --&gt;
&lt;!-- `\(&gt;\)`	| &gt; |maior que | `7 &gt; 5`  | TRUE  --&gt;
&lt;!-- `\(&lt;\)`	| &lt; |menor que | `7 &lt; 5` | FALSE --&gt;
&lt;!-- `\(\geq\)`| &gt;= | 	maior ou igual | `7 &gt;= 40/5` | FALSE --&gt;
&lt;!-- `\(\leq\)`| &lt;= |	menor ou igual | `7 &lt;= 40/5` | TRUE --&gt;
&lt;!-- `\(=\)`	| = |igual| `4 == 8/2` | TRUE --&gt;
&lt;!-- `\(\not=\)`| &lt;&gt; |	diferente| `4 != 8/2` | FALSE --&gt;

&lt;!-- Estes somente são usados para efetuar comparações, as quais só podem ser feitas entre dados do mesmo tipo. --&gt;

&lt;!-- ```{r} --&gt;
&lt;!-- x &lt;- "Meu Nome"; x == "MEU NOME" --&gt;
&lt;!-- ``` --&gt;


&lt;!-- O resultado de uma comparação é sempre um valor lógico.  --&gt;

&lt;!-- --- --&gt;

&lt;!-- ```{r} --&gt;
&lt;!-- 7 &gt; 5 # maior que --&gt;
&lt;!-- 7 &lt; 5 # menor que  --&gt;
&lt;!-- 7 &gt;= 40/5 # maior ou igual a --&gt;
&lt;!-- 7 &lt;= 35/5 # menor ou igaul a --&gt;
&lt;!-- 4 == 8/2 # igual a  --&gt;
&lt;!-- 4 != 8/2 # não igual a --&gt;
&lt;!-- ``` --&gt;


&lt;!-- --- --&gt;

&lt;!-- **Operadores Lógicos** ou **Booleanos**: são usados para combinar expressões relacionais e lógicas. Também retornam como resultado valores lógicos, ou seja, `\(V\)` ou `\(F\)`. --&gt;


&lt;!-- Operador	| Tipo	| Operação|	| Prioridade --&gt;
&lt;!-- :--- | :---: | :---: | :---: | :---: --&gt;
&lt;!-- NÃO |	Unário	| Negação |	 | 1 --&gt;
&lt;!-- E	| Binário	| Conjunção	|  | 2 --&gt;
&lt;!-- OU	| Binário	| Disjunção	|  | 3 --&gt;

&lt;!-- **Exemplos** --&gt;
&lt;!-- .pull-left[ --&gt;
&lt;!-- ```{r} --&gt;
&lt;!-- ! TRUE # Negação --&gt;
&lt;!-- TRUE &amp; FALSE # Conjunção --&gt;
&lt;!-- TRUE &amp; TRUE # Conjunção --&gt;
&lt;!-- ``` --&gt;
&lt;!-- ] --&gt;

&lt;!-- .pull-right[ --&gt;
&lt;!-- ```{r} --&gt;
&lt;!-- TRUE | FALSE # Disjunção --&gt;
&lt;!-- TRUE | TRUE # Disjunção --&gt;
&lt;!-- ``` --&gt;
&lt;!-- ] --&gt;

&lt;!-- --- --&gt;

&lt;!-- ## Ordem de prioridades dos operadores --&gt;

&lt;!-- ```{r, echo=FALSE, out.width="80%", fig.align='center'} --&gt;
&lt;!-- knitr::include_graphics("img/ordem-operadores.png") --&gt;
&lt;!-- ``` --&gt;

&lt;!-- Observações: --&gt;
&lt;!-- Operadores de igual prioridade, execução da esquerda para direita. --&gt;
&lt;!-- Para alterar a ordem de prioridade, utilizar parênteses. --&gt;

&lt;!-- --- --&gt;
&lt;!-- **Exercício** --&gt;

&lt;!-- Imagine que você está parado na beira de um penhasco e deixa cair uma pedra da borda. Assim que você solta a pedra, ela começa a cair em direção ao solo devido à força da gravidade. A aceleração da rocha ao cair é de `\(9,8\)` metros por segundo ao quadrado (m/s²), que é a aceleração da gravidade na Terra. --&gt;

&lt;!-- .pull-left[ --&gt;
&lt;!-- ```{r, echo=FALSE, out.width="90%", fig.align='center'} --&gt;
&lt;!-- knitr::include_graphics("img/holding.jpg") --&gt;
&lt;!-- ``` --&gt;
&lt;!-- ] --&gt;

&lt;!-- .pull-right[ --&gt;
&lt;!-- Nessa condição a rocha continuará acelerando até atingir a chamada  velocidade terminal, e então cairá com velocidade constante, pois a força de resistência do ar vai equilibrar a força da gravidade. --&gt;

&lt;!-- ] --&gt;
&lt;!-- --- --&gt;

&lt;!-- A velocidade terminal é a velocidade máxima que um objeto pode atingir ao cair através de um fluido, como ar ou água, devido ao equilíbrio entre a força da gravidade e a resistência do fluido. Assim, a fórmula para calcular a velocidade terminal de um objeto em queda é dada pela expressão: --&gt;

&lt;!-- $$ --&gt;
&lt;!-- v_t = \sqrt{\frac{2mg}{\rho .  A . C_D}} --&gt;
&lt;!-- $$ --&gt;
&lt;!-- Onde:   --&gt;
&lt;!-- `\(v_t\)` é a velocidade terminal em metros por segundo `\((m/s)\)`;   --&gt;
&lt;!-- `\(m\)` é a massa do objeto em quilogramas `\((kg)\)`;   --&gt;
&lt;!-- `\(g\)` é a aceleração da gravidade em metros por segundo ao quadrado `\((m/s²)\)`;   --&gt;
&lt;!-- `\(ρ\)` é a densidade do fluido em quilogramas por metro cúbico `\((kg/m³)\)`;   --&gt;
&lt;!-- `\(A\)` é a área da seção transversal do objeto perpendicular à direção do movimento em metros quadrados `\((m²)\)`;   --&gt;
&lt;!-- `\(C_D\)` é o coeficiente de arrasto, que depende da forma e das propriedades da superfície do objeto.   --&gt;
&lt;!-- --- --&gt;
&lt;!-- No exemplo da rocha caindo no ar, podemos assumir que a densidade do ar é de aproximadamente `\(1,21\)` kg/m³, e podemos estimar o coeficiente de arrasto para uma rocha esférica em torno de `\(0,47\)`. --&gt;
&lt;!-- Digamos que a rocha tenha uma massa de `\(1\)` quilograma e um raio `\(r\)` de `\(0,1 metros\)`. Sabendo que a seção transversal da rocha pode ser calculada por: --&gt;

&lt;!-- A = π.r² --&gt;

&lt;!-- Construa um código em R para calcular a velocidade terminal da pedra, não esqueça de documentar o seu código na forma de um pseudo-código. --&gt;

&lt;!-- ```{r, eval=FALSE} --&gt;
&lt;!-- início --&gt;
&lt;!--   // declaração de constantes --&gt;

&lt;!--   // declaração de variáveis --&gt;

&lt;!--   //entrada --&gt;

&lt;!--   //processamento --&gt;

&lt;!--   //saída --&gt;

&lt;!-- fim. --&gt;
&lt;!-- ``` --&gt;


&lt;!-- **Resposta**: a velocidade terminal da rocha caindo no ar será de aproximadamente:  --&gt;
&lt;!-- --- --&gt;

&lt;!-- ```{r} --&gt;
&lt;!-- ## declaração das constantes --&gt;
&lt;!-- g &lt;- 9.8 --&gt;
&lt;!-- rho &lt;- 1.2 --&gt;
&lt;!-- cd &lt;- 0.47 --&gt;

&lt;!-- ## declaração das variáveis --&gt;
&lt;!-- r &lt;- 0.1 --&gt;
&lt;!-- m &lt;- 1 --&gt;
&lt;!-- vt &lt;- 0 --&gt;

&lt;!-- ## processamento --&gt;
&lt;!-- A = pi*r^2 --&gt;
&lt;!-- vt &lt;- sqrt((2 * m * g) / (rho * A * cd)) --&gt;

&lt;!-- ## saída --&gt;
&lt;!-- cat(round(vt,2), " m/s") --&gt;
&lt;!-- ``` --&gt;


&lt;!-- --- --&gt;
&lt;!-- ## Projetos no R --&gt;

&lt;!-- No **RStudio** podemos criar projetos, que é uma pasta no seu computador ondes estarão todos os arquivos relativos para execução de trabalho, onde serão armazenados, os dados, os scripts das análises, os exercícios resolvidos e eventuais relatórios. --&gt;

&lt;!-- Recomenda-se que seja criada uma pasta em seu computador onde todas os projetos serão armazenados. --&gt;

&lt;!--   + Abra o `Windows Explorer` ![](img/winIcon.png) e clique duas vezes no Drive `C:/`. --&gt;

&lt;!-- ![](img/win_c.png) --&gt;

&lt;!-- --- --&gt;

&lt;!-- + Clique em `Início` e Selecione `Nova Pasta` ![](img/novapastaicon.png). --&gt;

&lt;!-- ![](img/novaPasta_dir.png) --&gt;

&lt;!--   + Atribua o nome `Projetos R` para a nova pasta. Nesta pasta serão salvos todos os projetos do R criados em seu computador. --&gt;

&lt;!-- --- --&gt;
&lt;!-- ## RStudio - Criando um Novo Projeto --&gt;

&lt;!--  +  Para criar um projeto, clique em `New Project...` no `Menu File`.  --&gt;

&lt;!--  + Na caixa de diálogo que aparecerá, clique em `New Directory` para criar o projeto em uma nova pasta ou `Existing Directory` para criar em uma pasta existente. --&gt;

&lt;!-- + No caso do presente exercício vamos clicar em `New Directory` e posteriormente clique em `New Project`. --&gt;

&lt;!-- ![](img/novos_projetos.png) --&gt;

&lt;!-- --- --&gt;

&lt;!-- + No campo `Directory Name:` atribua o nome de seu **novo projeto** (`Estatistica-Informatica`, no exemplo).   --&gt;
&lt;!-- + Clique em `Browse...` e selecione a pasta `C:/Projetos R`, previamente criada. --&gt;

&lt;!-- ![](img/novos_projetos_dir.png) --&gt;
&lt;!-- --- --&gt;

&lt;!-- Criando um projeto, o RStudio criará na pasta escolhida um arquivo `nome-do-projeto.Rproj`. Você pode usar esse arquivo para iniciar o RStudio já com o respectivo projeto aberto. --&gt;

&lt;!-- Quando um projeto estiver aberto no RStudio, o seu nome aparecerá no canto superior direito da tela. Na aba `Files`, aparecerão todos os arquivos contidos no projeto. --&gt;

&lt;!-- ```{r, echo=FALSE, out.width="100%", fig.align='center'} --&gt;
&lt;!-- knitr::include_graphics("img/rstudio1.png") --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;

&lt;!-- Você pode criar livremente novas pastas dentro da pasta do projeto. Por padrão, o R sempre começará a procurar arquivos na pasta raiz do projeto (é a pasta que contem o nome-do-projeto.Rproj). --&gt;

&lt;!-- Uma maneira fácil de navegar entre projetos é utilizar o menu disponibilizado quando clicamos no nome do projeto. Veja a figura a seguir: --&gt;


&lt;!-- ```{r, echo=FALSE, out.width="100%", fig.align='center'} --&gt;
&lt;!-- knitr::include_graphics("img/rstudio2.png") --&gt;
&lt;!-- ``` --&gt;

&lt;!-- + Agora, na aba `Files` clique no botão `New Folder` e crie a pasta `data` (dados em inglês), odne serão adicionados todas as bases de dados para serm carregadas futuramente em nosso projeto.   --&gt;

&lt;!-- --- --&gt;

&lt;!-- # Entrada de Dados no R --&gt;

&lt;!-- Antes de realizarmos a entrada de dados no R, vamos conhecer alguns conceitos básicos de estatística... --&gt;


&lt;!-- ```{r, echo=FALSE, out.width="50%", fig.align='center'} --&gt;
&lt;!-- knitr::include_graphics("img/data-import.png") --&gt;
&lt;!-- ``` --&gt;

&lt;!-- --- --&gt;
&lt;!-- ## O Estudo da Estatística --&gt;

&lt;!-- - Estatística é fundamental para o avanço do conhecimento científico, uma vez que a essência da Ciência é a observação e que o seu objetivo básico é a inferência, destacando-se nas áreas da *Saúde*, *Farmaceuticas*, *Melhoramento* (animal e vegetal), *Produção de alimentos* e demais *áreas científicas*. --&gt;


&lt;!-- - Os conhecimentos estatísticos são fundamentais para análise e interpretações das informações coletadas *em campo*. --&gt;


&lt;!-- - Várias técnicas de análises estatísticas ajudam o pesquisador a **confirmar as hipóteses** à respeito de um fenômeno de interesse. --&gt;

&lt;!-- --- --&gt;

&lt;!-- ##  Ciclo do Data-Science --&gt;

&lt;!-- ```{r, echo=FALSE, out.width="100%", fig.align='center'} --&gt;
&lt;!-- knitr::include_graphics("img/data-science.png") --&gt;
&lt;!-- ``` --&gt;

&lt;!-- Principais etapas de uma análise de dados --&gt;

&lt;!-- -- --&gt;

&lt;!-- - Todo fenômeno pode ser melhor investigado quando formulado um modelo matemático, que podem ser **determinísticos** ou **estocásticos** (*probabilísticos*).  --&gt;
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
  "highlightStyle": "github",
  "highlightLines": true,
  "countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
