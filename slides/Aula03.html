<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Estatística e Informática</title>
    <meta charset="utf-8" />
    <meta name="author" content="Alan Rodrigo Panosso alan.panosso@unesp.br" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Estatística e Informática
]
.subtitle[
## Aula 03 - Distribuição de Frequência
]
.author[
### Alan Rodrigo Panosso <a href="mailto:alan.panosso@unesp.br" class="email">alan.panosso@unesp.br</a>
]
.institute[
### Departamento de Ciências Exatas FCAV/UNESP
]
.date[
### (14-03-2024)
]

---



class: middle, center, inverse

## Distribuição de frequência de uma variável



&lt;img src="Aula03_files/figure-html/unnamed-chunk-1-1.png" style="display: block; margin: auto;" /&gt;

---
## Distribuição de frequência de uma variável

Quando analisamos uma variável aleatória (qualitativa ou quantitativa), deve-se conhecer a distribuição de frequência dessa variável por meio de suas possíveis realizações (observações). 

Nesse sentido, o objetivo dessa aula será apresentar as principais formas e visualização gráfica de variáveis quali e quantitativas. 

**Exemplo:** Considerando os [dados_turmas.xlsx](https://arpanosso.github.io/estatinfo/data/dados_turmas.xlsx) amostrados das turmas de Estatísticas temos:

&lt;img src="https://arpanosso.github.io/estatinfo/slides/img/exemplo_dados.png" style=" display: block; margin-left: auto; margin-right: auto;width: 65%"&gt;&lt;/img&gt;



---
**Tamanho da População `\((N)\)`**

O tamanho da população `\(N\)` é o número total dos elementos alvos da pesquisa. Muitas vezes não conhecemos esse valor. 

Em nosso exemplo, poderíamos entender como `\(N\)` o número de todos os alunos da Unesp que estão no segundo ano de sua graduação.

**Tamanho da amostra `\((n)\)`**

É o número total de registros de sua base de dados, ou seja o número total de elementos amostrados da população. 

O comando `glimpse` permite que veriquemos o tamanho do banco de dados em linhas (Rows - `\(n\)`) e colunas (Columns - variáveis).

Onde `chr`  representa variáveis do tipo **strings**, ou seja textos e `dbl` representa variáveis numéricas.


---

&lt;img src="img/R_logo.png" width="10%" style="display: block; margin: auto auto auto 0;" /&gt;



```r
library(tidyverse) 
dados_turmas &lt;- readxl::read_xlsx("../data/dados_turmas.xlsx")
glimpse(dados_turmas) 
```

```
#&gt; Rows: 44
#&gt; Columns: 6
#&gt; $ id          &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,…
#&gt; $ sexo        &lt;chr&gt; "F", "F", "F", "F", "M", "M", "M", "M", "M", "M", "M", "M"…
#&gt; $ cor_cabelo  &lt;chr&gt; "CC", "CE", "CC", "CE", "CE", "CC", "CC", "CE", "CC", "C",…
#&gt; $ cons_alcool &lt;dbl&gt; 4, 1, 2, 3, 4, 2, 1, 2, 2, 4, 3, 3, 3, 2, 3, 2, 3, 3, 3, 4…
#&gt; $ altura      &lt;dbl&gt; 1.68, 1.59, 1.70, 1.50, 1.76, 1.60, 1.84, 1.88, 1.90, 1.68…
#&gt; $ idade_anos  &lt;dbl&gt; 19, 20, 49, 20, 23, 28, 19, 20, 20, 19, 21, 21, 21, 18, 19…
```


---
### Exemplo da base de dados das turmas 

Construir uma tabela de frequências para a variável `sexo` contendo as frequências absolutas `\((n_i)\)`, as frequências relativas `\((f_i)\)` e a porcentagem `\((perc)\)` para as categoria existentes. 

Após isso, realizar a visualização de dados com gráficos de Colunas, Barras e Setores (Pizza ou *Pie*).


---
### Frequência Absoluta `\((n_i)\)`

É definida como o número de observações no conjunto de dados pertencentes à uma categoria ou classe da variável em estudo.

Então, consideramos `\(1\)` para `\(F\)` e `\(2\)` para `\(M\)`, temos:

`\(n_1 = 15\)`

`\(n_2 = 29\)`


---
Assim temos a primeira regra da análise de nossa base de dados, a soma da frequência absoluta das classes `\((k)\)` da variável cetegória é igual a `\(n\)`. 

$$
\sum \limits_{i=1}^{k}{n_i} = n
$$

Onde `\(k\)` é o número de categorias da variável em questão, no caso do `sexo`, temos duas categorias (M e F).

$$
\sum \limits_{i=1}^{k}{n_i} = n_1+n_2=15+29=44
$$

---

**Frequência Relativa `\((f_i)\)`**

É definida como a proporção de cada categoria em relação ao **Total de observações** `\((n)\)`, ou seja:

$$
f_i = \frac{n_i}{n}
$$

Portanto temos que, 

$$
f_1 = \frac{15}{44}=0,3409
$$ 

e   

$$
f_2 = \frac{29}{55}=0,6591
$$
---
Assim, temos que a soma das frequências relativas sempre será igual a `\(1\)`: 

$$
\sum \limits_{i=1}^{k} f_i=f_1+f_2 = 0,3409+0,6591 = 1
$$

onde `\(k\)` é o número de categorias da variável `sexo`, ou seja, `\(2\)`, nesse caso.

---

**Porcentagem de frequência `\((perc \text{ ou %})\)`**

Definida como o resultado da multiplicação da frequência relativa (proporção) por `\(100\)`.


`$$perc_1 = f_1 \times 100 = 0,3409 \times 100 = 34,09\% \\
perc_2 = f_2 \times 100 = 0,6591 \times 100 = 65,91\%$$`

---

Para essa tarefa, vamos utilizar o R. Precisaremos, então, fazer algumas operações nos dados das turmas e vamos usar o operador `PIPE` (`%&gt;%`), cujo atalho é `CTRL + SHIFT + M`. 

Vamos utilizar a função `n()` para contar cada ocorrência das diferentes categorias da variável  `sexo`.

- `group_by()` agrupa as categorias da variável `sexo`.
- `summarise()` cria o resumo dos dados, ou seja, contará o valor de cada categoria usando a função `n()` e salvará na coluna `ni`.
- `mutate()` é a função utilizada para calcular `\(f_i\)` e suas respectivas procentagens `\(prec_i\)` a partir da coluna `\(_i\)`.


```r
dados_turmas %&gt;%
  group_by(sexo) %&gt;% 
  summarise(ni=n()) %&gt;% # frequência Absoluta
  mutate(fi = ni/sum(ni),# frequência Relativa
         perc = fi*100) # porcentage m de frequência
```

```
#&gt; # A tibble: 2 × 4
#&gt;   sexo     ni    fi  perc
#&gt;   &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1 F        15 0.341  34.1
#&gt; 2 M        29 0.659  65.9
```

---

A partir da tabela de frequência, poderemos criar representações gráficas que nos auxiliarão na apresentação e interpretação do comportamento dos dados.

Essa etapa é a denominada de **Visualização de Dados**. 

---
class: middle, center, inverse

# VISUALIZAÇÃO DE DADOS
## (Variáveis Qualitativas)

---
## Visualização dos dados

Os tipos de gráficos podem variar de acordo com o tipo de variável, geralmente, para as variáveis qualitativas utilizamos os gráficos de `Barras`, `Colunas` ou de `Setores (Pizza ou Pie)`. 

Para isso, vamos utilizar a funções do pacote `ggplot2` que é carregado junto com o pacote `tidyverse`. 

O ggplot funciona na forma de camadas represetações gráficas e de formatações, que são adicionadas de acordo com a necessidade do usuário por meio do operador de adição `+` digitado ao final da cada linha.

---

**Gráfico de Colunas para Sexo**

Deve ser utilizado para variáveis categóricas (qualitativas ordinais ou nominais).


```r
dados_turmas %&gt;%
  group_by(sexo) %&gt;% 
  summarise(ni=n()) %&gt;% 
  mutate(fi = ni/sum(ni),
         perc = fi*100) %&gt;% 
  ggplot(aes(x=sexo, y=fi)) + 
  geom_col()
```

---

### Gráfico de Colunas para Sexo

&lt;img src="Aula03_files/figure-html/plot1-1.png" style="display: block; margin: auto;" /&gt;

---

### Gráfico de Barras para Sexo

Semelhante ao gráfico de colunas, contudo, com as barras na horizontal, facilita a leitura do nome das categorias.


```r
dados_turmas %&gt;%
  group_by(sexo) %&gt;% 
  summarise(ni=n()) %&gt;% 
  mutate(fi = ni/sum(ni),
         perc = fi*100) %&gt;% 
  ggplot(aes(x=fi,y=sexo)) + 
  geom_col(fill="aquamarine4",
           color="black") 
```
- o argumento `fill = "aquamarine4"` permite que possamos alterar a cor do preenchimeto (*fill*) da barra e o argumento `color="black"` permite a alteração da cor o contorno das barras. 

---

&lt;img src="Aula03_files/figure-html/plot2-1.png" style="display: block; margin: auto;" /&gt;

Outras cores são possíveis tente algumas [das cores no R](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf).

---

### Gráfico de Setores para Sexo

Também conhecido como gráfico de Pizza (ou torta em inglês - *pie*), ele representa cada valor de frequência relativa das diferentes categorias da variável em uma circunferência.

- A função `geom_bar()` associada à `coord_polar()` permite a transformação do gráfico de barras no gráfico de pizza.

- A função `theme_void()` retira elementos como linhas e nomes e números da representação gráfica.


```r
dados_turmas %&gt;%
  group_by(sexo) %&gt;% 
  summarise(ni=n()) %&gt;% 
  mutate(fi = ni/sum(ni),
         perc = fi*100) %&gt;% 
  ggplot(aes(x="",y=fi, fill=sexo)) + 
  geom_bar(stat="identity") +
  coord_polar("y", start=0) + 
  theme_void() 
```

---

&lt;img src="Aula03_files/figure-html/plot3-1.png" style="display: block; margin: auto;" /&gt;

---
#### Vamos Adicionar os valores de `\(fi\)` no gráfico


```r
dados_turmas %&gt;%
  group_by(sexo) %&gt;% 
  summarise(ni=n()) %&gt;% 
  mutate(fi = ni/sum(ni),
         perc = fi*100) %&gt;%
  ggplot(aes(x="",y=fi, fill=sexo)) +
  geom_bar(stat="identity") +
  coord_polar("y", start=0) +
  theme_void() +
  geom_text(
    aes(
*     label=paste0(round(perc), "%")),
*     position=position_stack(vjust = 0.5))
```

---

&lt;img src="Aula03_files/figure-html/plot3_1-1.png" style="display: block; margin: auto;" /&gt;

---

### Treemap

É uma técnica de visualização de dados que exibe hierarquias utilizando retângulos aninhados. 

Cada retângulo representa uma hierarquia de dados e é subdividido em retângulos menores que representam subcategorias.

Treemaps pode responder perguntas sobre os dados como: "Quais são as proporções de categorias para o total?"

---


```r
library(treemapify)
dados_turmas %&gt;%
  group_by(sexo) %&gt;% 
  summarise(ni=n()) %&gt;% 
  mutate(fi = ni/sum(ni),
         perc = fi*100) %&gt;%
  ggplot(aes(area = perc, fill = sexo)) +
  geom_treemap() +
  geom_treemap_text(
    aes(label = paste(sexo, 
                      paste0(round(perc, 2), "%"), sep = "\n")), 
    colour = "black") +
  theme(legend.position = "none") 
```

---
&lt;img src="Aula03_files/figure-html/plot3_5-1.png" style="display: block; margin: auto;" /&gt;
---
## Tabela de Frequência para a variável Cor de cabelo


Vamos, mais uma vez, utilizar o R para conseguirmos as tabelas e a representação gráfica. 


```r
dados_turmas %&gt;%
* group_by(cor_cabelo) %&gt;%
  summarise(ni=n()) %&gt;%      
  mutate(fi = ni/sum(ni),    
         perc = fi*100)      
```

```
#&gt; # A tibble: 4 × 4
#&gt;   cor_cabelo    ni     fi  perc
#&gt;   &lt;chr&gt;      &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1 C              6 0.136  13.6 
#&gt; 2 CC             8 0.182  18.2 
#&gt; 3 CE            29 0.659  65.9 
#&gt; 4 P              1 0.0227  2.27
```

---

### Gráfico de Colunas para Cor de cabelo


```r
dados_turmas %&gt;%
* group_by(cor_cabelo) %&gt;%
  summarise(ni=n()) %&gt;%      
  mutate(fi = ni/sum(ni),    
         perc = fi*100) %&gt;% 
  ggplot(aes(x=cor_cabelo,y=fi,
*            fill=cor_cabelo)) +
  geom_col(color="black")+
* theme_bw()
```

- ao passarmos o argumento `fill=cor_cabelo` dentro da função `aes()` estamos pedindo o mapeamento das cores de cabelo a partir de cores de preeenchimento diferentes.

- `aes()` representa a estética do gráfico, ou seja, quem é x, quem é y e quem deve ser mapeado.

- a função `theme_bw()` muda o padrão de cores e de linhas do gráfico. Existem outros padrões como `theme_classic`, `theme_minimal` entre outros.

---

&lt;img src="Aula03_files/figure-html/plot4-1.png" style="display: block; margin: auto;" /&gt;

---

### Gráfico de Barras para Cor de cabelo


```r
dados_turmas %&gt;%
* group_by(cor_cabelo) %&gt;%
  summarise(ni=n()) %&gt;%      
  mutate(fi = ni/sum(ni),    
         perc = fi*100) %&gt;% 
  ggplot(aes(x=fi, y=cor_cabelo,
             fill=cor_cabelo)) + 
  geom_col(color="black")+
  scale_fill_manual(values = c("salmon4",
                               "burlywood4",
                               "orange4",
                               "black"))+
  theme_minimal()
```
- utilize a função `scale_fill_manual()` para alterar as cores dos preenchimentos, se necessário.

---
&lt;img src="Aula03_files/figure-html/plot5-1.png" style="display: block; margin: auto;" /&gt;
---
### Gráfico de Setores para cor_cabelo


```r
dados_turmas %&gt;%
* group_by(cor_cabelo) %&gt;%
  summarise(ni=n()) %&gt;%      
  mutate(fi = ni/sum(ni),    
         perc = fi*100) %&gt;% 
  ggplot(aes(x="", y=fi, 
             fill=cor_cabelo)) + 
  geom_bar(stat="identity",color="black") +
  coord_polar("y", start=0) +
  theme_void()
```

---

&lt;img src="Aula03_files/figure-html/plot6-1.png" style="display: block; margin: auto;" /&gt;

---

#### Vamos Adicionar os valores de `\(perc\)` no gráfico


```r
dados_turmas %&gt;%
* group_by(cor_cabelo) %&gt;%
  summarise(ni=n()) %&gt;%      
  mutate(fi = ni/sum(ni),    
         perc = fi*100) %&gt;%
  ggplot(aes(x="",y=fi, fill=cor_cabelo)) +
  geom_bar(stat="identity") +
  coord_polar("y", start=0) +
  theme_void() +
  geom_text(
    aes(
*     label=paste0(round(perc), "%")),
*     position=position_stack(vjust = 0.5))
```

---

&lt;img src="Aula03_files/figure-html/plot6_1-1.png" style="display: block; margin: auto;" /&gt;


---
#### Treemap para cor dos cabelos


```r
library(treemapify)
dados_turmas %&gt;%
  group_by(cor_cabelo) %&gt;% 
  summarise(ni=n()) %&gt;% 
  mutate(fi = ni/sum(ni),
         perc = fi*100) %&gt;%
  arrange(ni) %&gt;% 
  ggplot(aes(area = perc, fill = cor_cabelo)) +
  geom_treemap() +
  geom_treemap_text(
    aes(label = paste(cor_cabelo, 
                      paste0(round(perc, 2), "%"), sep = "\n")), 
    colour = "black") +
  theme(legend.position = "none") +
  scale_fill_manual(values = c("salmon4",
                               "burlywood4",
                               "orange4",
                               "darkgray"))
```

---
class: middle, center, inverse

# VISUALIZAÇÃO DE DADOS
## (Variáveis Quantitativas)

---
## Tabela de frequência e visualização para Idade em anos (discreta)

Quando a variável  for quantitativa discreta, os mesmos gráficos de variáveis qualitativas podem ser utilizados. Porém, também recomendamos a utilização dos gráficos `boxplot`, `histograma` e `Função distribuição acumulada`.

Pra a variável `idade_anos` vamos criar a tabela de frequência;


```r
dados_turmas %&gt;%
  group_by(idade_anos) %&gt;% 
  summarise(ni=n()) %&gt;%      
  mutate(fi = ni/sum(ni),    
         perc = fi*100)    
```


---


| idade_anos| ni|        fi|      perc|
|----------:|--:|---------:|---------:|
|         18|  6| 0.1363636| 13.636364|
|         19| 14| 0.3181818| 31.818182|
|         20|  9| 0.2045455| 20.454545|
|         21|  3| 0.0681818|  6.818182|
|         22|  3| 0.0681818|  6.818182|
|         23|  5| 0.1136364| 11.363636|
|         24|  1| 0.0227273|  2.272727|
|         27|  1| 0.0227273|  2.272727|
|         28|  1| 0.0227273|  2.272727|
|         49|  1| 0.0227273|  2.272727|

---

## Tabela de frequência para variável Altura (Quantitativa Contínua)

Quando a variável quantitativa for contínua, recomenda-se a utilização dos gráficos `histograma`  e `Função de distribuição acumulada`. 

Devemos, inicialmente construir a tabela de frequência da variável `altura`. Porém, os valores de uma variável contínua não se repetem, mesmo que isso aparentemente ocorra na base de dados. 

Em teoria suas realizações podem assumir qualquer valor dentro da reta dos números reais, portanto, ao mensurar uma variável contínua, obtém-se apenas uma aproximação de seu verdadeiro valor dada pelo instrumento de medida.

---

Para exemplificar, vamos criar `\(5\)` classes de alturas a partir da função `cut()`.


```r
dados_turmas %&gt;%
  mutate(
*   classes_altura = cut(altura,5)
  ) %&gt;% 
  group_by(classes_altura) %&gt;% 
  summarise(ni=n()) %&gt;%      
  mutate(fi = ni/sum(ni),    
         perc = fi*100)    
```


|classes_altura | ni|        fi|      perc|
|:--------------|--:|---------:|---------:|
|(1.5,1.58]     |  4| 0.0909091|  9.090909|
|(1.58,1.66]    |  7| 0.1590909| 15.909091|
|(1.66,1.75]    | 12| 0.2727273| 27.272727|
|(1.75,1.83]    | 14| 0.3181818| 31.818182|
|(1.83,1.91]    |  7| 0.1590909| 15.909091|

---

### Amplitude Total

Para melhor entendermos como a função `cut()` funciona, será necessário conhecermos mais algumas medidas para a construção do histograma. Vamos iniciar com a Amplitude total `\((\Delta)\)`, definida como a diferença entre o valor máximo menos o valor mínimo da variável.

`$$\Delta = Máximo - Mínimo$$`

Para os dados de altura temos, `\(\Delta = 1,91\;m-1,50\;m = 0,41 \;m\)`

No R podemos calcular a amplitude total com as funções do pacote `base`, para isso devemos, primeiramente, extrair de `dados_turmas` a variável (coluna) `altura` por meio do operador de acesso de listas `$`.


```r
altura &lt;- dados_turmas %&gt;% 
  pull(altura)
```

Agora vamos encontrar o máximo e o mínimo e calcular a diferença.


```r
D &lt;- max(altura) - min(altura)
D
```

```
#&gt; [1] 0.41
```

---
### Número de intervalos de classes `\((k)\)` 

Definiremos `\(k\)` como sendo o número de **sub-intervalos** da Amplitude Total. Uma boa representação apresenta um `\(k\)` **NUNCA** inferior a `\(5\)` ou superior a `\(15\)`, pois com um pequeno número de classes, perde-se informação, e com um grande número de classes, o objetivo de resumir os dados fica prejudicado.



```r
k &lt;- 5
```


### Amplitude de classe `\((\Delta_i)\)`

É o tamanho de cada um dos `\(k=5\)` sub-intervalos, dado pela amplitude total dividida pelo número de intervalos.

`$$\Delta_i = \frac{\Delta}{k}$$`
Para os dados de altura:

`\(\Delta_i = \frac{\Delta}{k} = \frac{0.41\;m}{5} = 0,082 \;m\)`

---
Assim, temos


```r
Di = D/k
Di
```

```
#&gt; [1] 0.082
```
Cada um dos `\(5\)` intervalos terá uma amplitude de `\(0,086\)` m. Ou seja, o cálculo dos  limites das classes é feito a partir da adição ao valor Mínimo o valor de `\(\Delta_i\)` `\(k\)` vezes:


```r
limites &lt;- min(altura)+ 0:k * Di
limites
```

```
#&gt; [1] 1.500 1.582 1.664 1.746 1.828 1.910
```
---

Obervem que foi essa a metodologia utilizada pela função `cut()` para calcular os limites de classes, e essa é a metodologia clássica para lidar com dados contínuos e os agrupar em classes.


|classes_altura | ni|        fi|      perc|
|:--------------|--:|---------:|---------:|
|(1.5,1.58]     |  4| 0.0909091|  9.090909|
|(1.58,1.66]    |  7| 0.1590909| 15.909091|
|(1.66,1.75]    | 12| 0.2727273| 27.272727|
|(1.75,1.83]    | 14| 0.3181818| 31.818182|
|(1.83,1.91]    |  7| 0.1590909| 15.909091|

```
#&gt; [1] 1.500 1.582 1.664 1.746 1.828 1.910
```


---
## Gráfico histograma (frequências absolutas)

A partir da tabela anterior, pode-se construir o gráfico de frequência de cada classe de valor de altura, denominado **Histograma**. 


```r
dados_turmas %&gt;% 
* ggplot(aes(x=altura,y=..count..))+
  geom_histogram(breaks = limites,
                 color="black",
                 fill="gray")
```
O código acima gera um histograma com `\(5\)` barras onde o eixo `y` será a frequência absoluta, ou seja, a contagem (`..count..`) de quantos valores de altura estão dentro de uma determinada classe.

A opção `breaks = limites` deixa o histograma igual ao observado na tabela anterior.

---

## Histograma da altura (m)

&lt;img src="Aula03_files/figure-html/plot10-1.png" style="display: block; margin: auto;" /&gt;

---

## Gráfico histograma (frequências relativas)

Ao longo de nosso curso, vamos estudar que a frequência relativa `\(f_i\)` é uma estimativa empírica da probabilidade `\(P(X=x_i)\)`, assim é interessante que a área total da figura do histograma seja igual a `\(1\)`, correspondendo à soma total das frequências relativas `\(( f_i )\)`. 

Então, para construção do histograma, sugere-se usar no eixo das ordenadas os valores de `\(fi / \Delta_i\)` (denominado densidade de frequência), ou seja, da medida que indica qual a concentração por unidade da variável.


```r
dados_turmas %&gt;% 
* ggplot(aes(x=altura,y=..density..))+
  geom_histogram(breaks = limites,
                 color="black",
                 fill="gray")
```

Para isso utilizamos `y=..density..`.

---


&lt;img src="Aula03_files/figure-html/plot11-1.png" style="display: block; margin: auto;" /&gt;

---

## Densidade de frequência `\((d_i)\)`

Agora vamos atualizar a tabela com o valor de densidade de frequência, dado por:

`$$d_i=\frac{f_i}{\Delta_i}$$`


```r
dados_turmas %&gt;%
  mutate(
    classes_altura = cut(altura,5)
    ) %&gt;% 
  group_by(classes_altura) %&gt;% 
  summarise(ni=n()) %&gt;%      
  mutate(fi = ni/sum(ni),    
         perc = fi*100,
*        di=fi/Di)
```

---


|classes_altura | ni|        fi|      perc|       di|
|:--------------|--:|---------:|---------:|--------:|
|(1.5,1.58]     |  4| 0.0909091|  9.090909| 1.108648|
|(1.58,1.66]    |  7| 0.1590909| 15.909091| 1.940133|
|(1.66,1.75]    | 12| 0.2727273| 27.272727| 3.325942|
|(1.75,1.83]    | 14| 0.3181818| 31.818182| 3.880266|
|(1.83,1.91]    |  7| 0.1590909| 15.909091| 1.940133|

---

## Medidas  Acumuladas

As medidas acumuladas são interessantes para compor algumas vizualizações:

`\(N_i\)`: Frequência Absoluta Acumulada.

`\(F_i\)`: Frequência Relativa Acumulada.

`\(Perc\)`: Porcentagem de Frequência Acumulada.


```r
dados_turmas %&gt;%
  mutate(
    classes_altura = cut(altura,5)
    ) %&gt;% 
  group_by(classes_altura) %&gt;% 
  summarise(ni=n()) %&gt;%      
  mutate(fi = ni/sum(ni),    
         perc = fi*100,
         di=fi/Di,
*        Ni = cumsum(ni),
*        Fi = cumsum(fi),
*        Perc = cumsum(perc))
```

---

# Tabela de Frequência para Altura


|classes_altura | ni|        fi|      perc|       di| Ni|        Fi|       Perc|
|:--------------|--:|---------:|---------:|--------:|--:|---------:|----------:|
|(1.5,1.58]     |  4| 0.0909091|  9.090909| 1.108648|  4| 0.0909091|   9.090909|
|(1.58,1.66]    |  7| 0.1590909| 15.909091| 1.940133| 11| 0.2500000|  25.000000|
|(1.66,1.75]    | 12| 0.2727273| 27.272727| 3.325942| 23| 0.5227273|  52.272727|
|(1.75,1.83]    | 14| 0.3181818| 31.818182| 3.880266| 37| 0.8409091|  84.090909|
|(1.83,1.91]    |  7| 0.1590909| 15.909091| 1.940133| 44| 1.0000000| 100.000000|

---

## Histograma e Polígono de Frequência

Obtemos o polígono de frequências unindo por uma poligonal (segmentos de retas) os pontos correspondentes às frequências, das classes, centradas nos pontos médios de cada classe. 

Para se obter as interseções do polígono com o eixo horizontal, cria-se em cada extremo do histograma uma classe com frequência nula.

No R:


```r
dados_turmas %&gt;% 
* ggplot(aes(x=altura, y=..count..))+
  geom_histogram(breaks = limites,
                 color="black",
                 fill="gray") +
* geom_freqpoly(breaks=limites,color="red")
```

---

&lt;img src="Aula03_files/figure-html/plot12-1.png" style="display: block; margin: auto;" /&gt;


---

## Histograma e Estimativas de densidade suavizadas


Calcula e desenha a estimativa da densidade, que é uma versão suavizada do histograma. Esta é uma alternativa útil para dados contínuos que vêm de uma distribuição suave subjacente. 


```r
dados_turmas %&gt;% 
* ggplot(aes(x=altura,y=..density..))+
  geom_histogram(breaks = limites,
                 color="black",
                 fill="white") +
  geom_density(color="red",
               fill="green",
*              alpha=0.05)
```

- Observe que o histograma foi construído com as frequências absolutas `\((n_i)\)`, ou seja, `y=..density..`. Utilizamos a função `geom_density()`.  
- O argumento `alpha=0.05` controla a transparência do preenchimento. 

---

&lt;img src="Aula03_files/figure-html/plot12_1-1.png" style="display: block; margin: auto;" /&gt;


---

## Função de Distribuição Acumulada


A função de distribuição acumulada descreve como probabilidades são associadas aos valores ou aos intervalos de valores de uma variável aleatória. Em outras palavras, ela representa a probabilidade de uma variável aleatória ser menor ou igual a um valor real qualquer `\(x\)`. 

$$
F(x) = P(X \leq x) \in [0,1].
$$

Para uma variável aleatória contínua (`altura`):

`\(\int \limits_{- \infty }^x f(x_i) dx\)`


```r
dados_turmas %&gt;% 
  ggplot(aes(x=altura))+ 
* stat_ecdf(geom = "line",color="red")
```

---

&lt;img src="Aula03_files/figure-html/plot13-1.png" style="display: block; margin: auto;" /&gt;

---

## Função de Distribuição Acumulada

No caso da variável aleatória discreta (`idade_anos`):

`\(F(x) = \sum \limits_{x_i&lt;x} f(x_i)\)`


```r
dados_turmas %&gt;% 
* ggplot(aes(x=idade_anos))+
  stat_ecdf(geom = "line",color="red")
```

---
&lt;img src="Aula03_files/figure-html/plot14-1.png" style="display: block; margin: auto;" /&gt;

---
class: middle, center, inverse

## Prática para Casa: Instalação de Pacotes no R

![](img/pacotes_r.png)

[Link do Video](https://drive.google.com/drive/u/0/folders/1O-sGhicXs6unUY_y1JW8yKSHm76VVMCX)

---
**Pacote em R**

Um pacote é uma coleção de funções, exemplos e documentação. A funcionalidade de um pacote é frequentemente focada em uma metodologia estatística especial" (**Everitt &amp; Hothorn**).


![](img/fig08.png)

Pacotes no R são coleções de funções, exemplos e documentações, que devem ser previamente instalados e alocados no ambiente pela função `library`.

---
## Pacotes básicos

Liste os pacotes carregados no ambiente com:


```r
(.packages())
```

```
#&gt;  [1] "treemapify" "lubridate"  "forcats"    "stringr"    "dplyr"     
#&gt;  [6] "purrr"      "readr"      "tidyr"      "tibble"     "ggplot2"   
#&gt; [11] "tidyverse"  "stats"      "graphics"   "grDevices"  "utils"     
#&gt; [16] "datasets"   "methods"    "base"
```

O retorno da função é uma lista de nomes, `caracteres` (ou `strings`), na forma de um *objeto* denominado **vetor**. Observe que cada pacote (elemento) é referenciado dentro do vetor por um índice, um número inteiro `\([\;i\;]\)` apresentado entre colchetes **[i]**.

Carregue um pacote chamando a função `library`.


```r
library(MASS)
```


---

Agora, liste novamente os pacotes e observe a diferença no retorno da função.


```r
(.packages())
```

```
#&gt;  [1] "MASS"       "treemapify" "lubridate"  "forcats"    "stringr"   
#&gt;  [6] "dplyr"      "purrr"      "readr"      "tidyr"      "tibble"    
#&gt; [11] "ggplot2"    "tidyverse"  "stats"      "graphics"   "grDevices" 
#&gt; [16] "utils"      "datasets"   "methods"    "base"
```

Observe que o pacote `MASS` agora está no ambiente de trabalho. 


---

### Instalando pacotes

Para a realização de procedimentos estatístico e manipulação de arquivos durante o curso, serão necessários vários pacotes que não fazem parte do `base` do R, que deverão ser instalados.

**Utilizando a opção** `Packages\Install\nome do pacote`

&lt;img src="img/install_pac.png" width="450px" style="display: block; margin: auto;" /&gt;


Instale os pacotes:  
 
 * `tidyverse`   
 * `agricolae`  

---
Os pacotes também podem ser instalados a partir das linhas de comandos:


```r
install.packages("tidyverse")
install.packages("agricolae")
```


Agora podemos carregar esses pacotes em nosso ambiente de trabalho.


```r
library(tidyverse)
library(agricolae)
```

Vamos agora criar uma "Pipe Line" para visualização de um banco de dados


```r
mtcars %&gt;% 
  glimpse()
```

```
#&gt; Rows: 32
#&gt; Columns: 11
#&gt; $ mpg  &lt;dbl&gt; 21.0, 21.0, 22.8, 21.4, 18.7, 18.1, 14.3, 24.4, 22.8, 19.2, 17.8,…
#&gt; $ cyl  &lt;dbl&gt; 6, 6, 4, 6, 8, 6, 8, 4, 4, 6, 6, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 8,…
#&gt; $ disp &lt;dbl&gt; 160.0, 160.0, 108.0, 258.0, 360.0, 225.0, 360.0, 146.7, 140.8, 16…
#&gt; $ hp   &lt;dbl&gt; 110, 110, 93, 110, 175, 105, 245, 62, 95, 123, 123, 180, 180, 180…
#&gt; $ drat &lt;dbl&gt; 3.90, 3.90, 3.85, 3.08, 3.15, 2.76, 3.21, 3.69, 3.92, 3.92, 3.92,…
#&gt; $ wt   &lt;dbl&gt; 2.620, 2.875, 2.320, 3.215, 3.440, 3.460, 3.570, 3.190, 3.150, 3.…
#&gt; $ qsec &lt;dbl&gt; 16.46, 17.02, 18.61, 19.44, 17.02, 20.22, 15.84, 20.00, 22.90, 18…
#&gt; $ vs   &lt;dbl&gt; 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,…
#&gt; $ am   &lt;dbl&gt; 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0,…
#&gt; $ gear &lt;dbl&gt; 4, 4, 4, 3, 3, 3, 3, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3,…
#&gt; $ carb &lt;dbl&gt; 4, 4, 1, 1, 2, 1, 4, 2, 2, 4, 4, 3, 3, 3, 4, 4, 4, 1, 2, 1, 1, 2,…
```

O simbolo para operação de arquivos de dados é o pipe `%&gt;%` que pode ser criado a partir do atalho `CTRL + SHIFT + M`

---

## Carregando os dados no R
Para carregar o banco de dados da turma no R, siga os passos:  
1.Faça o Download dos [dados_turmas.xlsx](https://arpanosso.github.io/estatinfo/data/dados_turmas.xlsx).    

2.Salve em uma pasta `data` dentro de um projeto do R previamente criado.

&lt;img src="https://arpanosso.github.io/estatinfo/slides/img/download_.png" style=" display: block; margin-left: auto; margin-right: auto;width: 85%"&gt;&lt;/img&gt; 

---

3.Na aba **Environment** do RStudio selecione **Import Dataset/From Excel...** como apresentado abaixo.

&lt;img src="https://arpanosso.github.io/estatinfo/slides/img/importa_r.png" style=" display: block; margin-left: auto; margin-right: auto;width: 95%"&gt;&lt;/img&gt; ]

---

4.Selecione **Browse** (destacado em vermelho no canto direito superior).

&lt;img src="https://arpanosso.github.io/estatinfo/slides/img/importa_r1.png" style=" display: block; margin-left: auto; margin-right: auto;width: 95%"&gt;&lt;/img&gt; 

---

5.Na próxima janela busque o arquivo da base de dados **dados_turmas.xlsx** que salvamos na pasta "*data"*,  selecione o arquivo e clique em **Open**.

&lt;img src="https://arpanosso.github.io/estatinfo/slides/img/importa_r2.png" style=" display: block; margin-left: auto; margin-right: auto;width: 95%"&gt;&lt;/img&gt;

---
6.Na janela serão apresentados os dados, **NÃO CLIQUE EM IMPORT**, ao invés disso, **selecione e copie o código** para a importação dos dados. Após isso **CLIQUE EM CANCEL**. 

&lt;img src="https://arpanosso.github.io/estatinfo/slides/img/importa_r3.png" style=" display: block; margin-left: auto; margin-right: auto;width: 95%"&gt;&lt;/img&gt;

---

7.Cole o código no seu script do R e o execute. Os dados serão salvos no objeto `dados_turmas`. Se necessário, instale o pacote `readxl` com as opções da aba **Packages/Install** ou com o comando `install.packages("readxl")`.


```r
library(readxl)
dados_turmas &lt;- read_excel("data/dados_turmas.xlsx")
View(dados_turmas)
```



&lt;img src="https://arpanosso.github.io/estatinfo/slides/img/importa_r4.png" style=" display: block; margin-left: auto; margin-right: auto;width: 60%"&gt;&lt;/img&gt;
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
